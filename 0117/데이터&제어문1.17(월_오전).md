실습
-> Jupyter 노트북

스크립트 실행
-> 평가

Pycharm -> 알고리즘
Text editor -> 메모장 + a
Visual Studio Code -> 코딩

#####################################################
변수
( 왼 ) = ( 오 )
 이름      값
' = ' -> ' 할당한다'

객체 => 숫자,문자,클래스 등 값을 가지고 있는 모든것
다른 객체를 언제든 할당할 수 있기 때문에 -> ' 변수 ' 라고 불림

변수 연산
숫자 (연산) 숫자
문자 (연산) 문자   => 가능


식별자
식별자 이름은 영문 알파벳, 언더스코어( _ ) , 슷지러 그상
첫 글자에 숫자가 올 수 없음
대소문자 구별
예약어 사용 불가

사용자 입력
-> 사용자로 부터 값을 입력
input() 함수

##################################################
자료형
None -> 값이 없음

불린(Boolean)
True / False 타입
다음은 False로 변환
-> 비어있는것들

수치형
모든 정수의 타입은 -> int
정수가 아닌 모든 실수는 -> float

Floating point rounding error
실수 연산 과정에서 발생 가능

epslion => 차이


' <= ' 이하
비교 연산자

문자열
모둔 문자는 str 타입
문자열은 ' , " 활용하여 표기 (하나의 문장부호를 선택하여 유지)


Immutable = ' 어떠한 값이 불변하다 '

Iterable
문자열은 반복 가능

a='123'
for char in a:
    print(char)
1
2
3

삼중 따옴표
따옴표 안에 따옴표를 넣을 때,
여러줄을 나눠 입력하기 편함

Escpae sequence
\n 줄바꿈
\t 탭

String Interpolation ( 문자열 사이에 변수 )
%formatting
print('Hello, %s' %name)
%s => 문자 %d => 정수 %f => 실수

str.format()
print('Hello, {}! 성적은'.format(name,score))

f-strings:python 3.6+
print(f'Hello, {name}! 성적은 {score}')

f-string => 소수점 표기 연산 가능
{pi : .3 } , {pi * 2 * 2 }


컨테이너
여러개의 값을 담을 수 있는 (객체), 서로 다른 자료형을 저장

컨테이너 분류
순서가 있는 데이터(Ordered) vs 순서가 없는 데이터(Unordered)
순서가 있다 != 정렬되어있다.

시퀀스형(순서가있는) => 리스트(가변), 튜플(불변), 레인지(불변)
비시퀀스(순서가없는) => 세트(가변),딕셔너리(가변)

시퀀스형컨테이너
리스트
순서를 가지는 0개 이상의 객체를 참조하는 자료형
생성된 이후 내용 변경이 가능 -> 가변자료형
유연성 때문에 파이썬에서 가장 흔히 사용
생성방법
my_list=[]
another_lis=list()
location=[ '서울' ,'대전', '구미' ]
location[0]
>> '서울'

튜플
순서를 가지는 0개 이상의 객체를 참조하는 자료형
생성 후 , 담고있는 개체 변경이 불가 -> 불변자료형
항상 소괄호로 표시
생성방법
( 1, 2, 3, 1 )
tuple( (1, 2, 3, 1) )
소괄호 ( () ) 혹은  tuple() 을 통해 생성
값에 대한 접근은 my_tuple[ i ]
값 변경은 불가능
튜플 생성시 주의 사항
하나의 항목으로 구성된 튜플은  생성 시 값 뒤에 쉼표
복수 항목의 경우,
쉼표 불필요
a=1, (단일 항목)
b=1,2,3 (복수 항목)

레인지(Range)
숫자의 시퀀스를 나타내기 위해 사용
기본형 : range(n)
0 부터 n-1 까지의 시퀀스
범위 지정 : range(n,m)
n 부터 m-1 까지의 숫자 시퀀스
범위 및 스텝 지정 : range(n,m,s)
n 부터 m-1 까지 s 만큼 증가

list(range(1,3,-1))
[]
list(range(6,1,1))
[]


패킹/언패킹 연산자
x *y= 1,2,3,4
print(x)
1
print(y)
[2,3,4]

비시퀀스형 컨테이너
셋(Set)
순서없이 0개 이상의 해시가능한 객체를 참조하는 가능형
담고 있는 개체를 삽입 변경,삭제 가능 -> 가변자료형
수학에서의 집합과 동일한 구조
중복없이 순서가 없는 자료구조
중괄호 ( {} ) 혹은 set()을 통해 생성
{1, 2, 3, 1, 2}
>> {1, 2, 3}

{} => 빈 중괄호는 딕셔너리
>>class ='dict'

blank_set = set()
>>class = 'set'

셋을 활용하면 다른 컨테이너에서 중복된 값을 쉽게 제거할 수 있음
단, 이후 순서가 무시되므로 순서가 중요한 경우 사용 불가


딕셔너리
순서없이 키-값(Key-Value) 쌍으로 이뤄진 객체를 참조하는 자료형
dict 의 키 (key )
해시 가능한 불변 자료형만 가능
Key 의 값 ( values )
어떠한 형태는 상관이 없음

중괄호 ( {} ) , dict()을 통해 생성
dict_a = { 'a' : 'apple ' , 'b' : 'banana' , 'list' : [1,2,3] }
키에는 리스트 생성 불가
dict_a['list']
[ 1, 2 ,3 ]

형 변환 
암시적 형 변환 (Implicit)
파이썬 내부적으로 자료형 변환 ( 사용자 의도 x )

명시적 형 변환 (Explicit)
사용자가 의도적으로 자료형 변환 하는 경우

암시적 형 변환
True + 3
>> 4
>> ( True가 명시적으로 True-> 1로 변환 )

명시적 형 변환
int
-> str* , float => int
float
-> str* int => float
str
-> int,float,list,tuple,dict =>str
'3'+4
=>ValueError
int('3') + 4
=> 7
int('3.5')+5
=>ValueError


형 변환 중요 -> 레인지와 딕셔너리로 변환 불가능
다만 Range -> list 변환 가능
딕셔너리를 변환할 때 -> Key만 나오고 Value는 안나옴

연산자(Operator)의 종류
산술,비교,논리,복함,멤버십,식별

산술 연산자
->기본적인 사칙연산
+, - , *, /
' // ' -> 몫
' ** ' -> 거듭제곱
' % ' -> 나머지

divmod()함수 몫과 나머지 나옴
divmod(5,2)
>>(2,1)

비교 이산자
< = 이하
>= 이상
>== 같음
>!= 같지않음
>is 객체 아이덴티티( OOP )
>is not 객체 아이덴티티가 아닌경우

값을 비교하여 , True/False 값 리턴

논리 연산자
and, or , not
일반적으로 비교연산자와 함께 사용됨

논리연산자 단축평가
결과가 확실한 경우 두번째 값은 확인하지 않음
a= 5 and 4
print(a)
>> 4 (and 연산자는 5와 4 둘다 True 여야 하기 때문에 )

a = 5 or 3
print(b)
>>5 (or 연산자는 5 또는 3 하나만 True 여도 돼서 5가 True 이므로 5 출력 )

and 연산에서 첫번째 False 인 경우 False -> 첫번째 값 반환
or 연산에서 첫번째 False 인 경우 무조건 True -> 첫번째 값 


식별 연산자
is 연산자를 통해 동일한 객체 인지 확인

맴버십 연산자
포함 여부 확인
in , not in
#리스트
1 in [3, 2]
>> False
>> #문자열
>> 'a' in 'apple'
>> True
>> 'b' not in 'apple'
>> True

시퀀스형 연산자
산술 연산자 ( + )
[1,2] + ['a']
>> [1,2,'a']
>> 반복 연산자(*)
>> [0]*8
>> [0,0,0,0,0,0,0,0]

인덱싱(Indexing)
시퀀스의 특정 인덱스 값에 접근
	-> 해당 인덱스가 없는 경우 IndexERROR
[1,2,3][2]
>>3
>>(1,2,3)[0]
>>1
>>[1,2,3][100]
>>IndexError

슬라이싱(Slicing)
[1,2,3,5][1:4]
[2,3,5]

(1,2,3)[:2]
(1,2)

문자열 슬라이싱 예제
s[ : : ] =>'abcdfght'
s[ : : -1 ] => 'ihgfedcba'

| 합집합
& 교입합
- 여집합
^ 대칭차
Key-Value -> dict
중복없이 순서가 없음 -> set
순서가있는 시퀀스 -> list

문자들의 나열 -> 스트링

패킹/언패킹
x, *y = i , [j, k .... ]
패킹

* -> 뒤에 있는것을 리스트로 묶음
언패킹
def multiply(x, y, z):
	return x*y*z
numbers = [ 1, 2, 3 ]
multiply(*numbers)
>>6
>>==> *numbers로 list[1,2,3]을 언패킹하여 함수에 대입

*패킹의 경우, 리스트로 대입
*언패킹의 경우 튜플로 대입

#########################
a,b,l = input().split()
1 2 3
입력시 -> split()함수가 띄어쓰기를 기준으로 리스트를 만들어 값을 만들어줌