# 0209_TIL



#### List 개념



**알고리즘**

> 문제를 해결하기 위한 절차나 방법

의사코드 와 순서도



##### 좋은 알고리즘

1. 정확성	2. 작업량	3.메모리 사용량	4.단순성	5.최적성



### 시간 복잡도 ; 빅-오(O) 표기법

- 시각 복잡도 함수중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수는 생략하여 표시



### 배열은 무엇인가?

- 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
- 다수의 변수로는  하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

#### 1차원 배열 선언

arr = lilst() , 	arr = [] , 	arr = [1,2,3]	, arr = [0]* 10



### 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은값 부터 큰 값 ( 오름차순 ) 혹은  반대 (내림차순) 순서로 재배열
- 키
  - 자료를 정렬하는 기준이 되는 특정 값

##### 정렬의 종류

- 버블 정렬 , 카운팅 정렬, 선택 정렬 , 퀵 정렬 , 삽입 정렬 ,병합 정렬

#### 버블 정렬

- 인접한 두개의 원소를 비교하여 자리를 계속 교환하는 방식
- 코딩이 가장 손 쉽다.

정렬 과정

- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리

> 나에게 주어진 인덱스 범위를 확인하는 것이 가장 중요!
>
> 왼쪽 오른쪽 어디를 기준으로 할 것 인가?

```python
def bubble_sort(a,N):
    for i in range(N-1,0,-1): #정렬 구간 끝
        for j in range(i): # 비교할 왼쪽 원소
            if j[i] < j[i+1]:
                j[i] = j[i+1]
    return
```

```python
#tip
for x in arr:
	pinrt(x, end = '')
print()
=
print(*arr)
```



### 카운팅 정렬(Counting Sort)

- 항목들의 순설르 결정하기 위해 집합에 각 항목이 몇 개 씩 있는지 세는 작업을 하여,

  선형 시간에 정렬하는 효율적인 알고리즘

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

- n이 비교적 작을 때만 가능

> 숫자를 세는 거를 이해하자.
>
> 누적 갯수를 새는 걸 이해 하자

```python
def counting_sort(A , B ,k):
    # A[] -- 입력 배열 ( 1 to k )
    # B[] -- 정렬된 배열
    # c[] -- 카운트 배열
    c = [0] * (k+1)
    for i in range(0, len(A)):
        c[A[i]] += 1
    
    for i in range(1, len(c)):
        c[i] = c[i-1]
    
    for i in range(len(B)-1, -1 ,-1):
        c[A[i]] -= 1
        B[c[A[i]]] = A[i]

    return
```





### 완전 검색

- 모든 경우의 수를 나열해보고 확인하는 기법

- Brute - fore 기법

- 수행속도는 느리지만 해답을 찾을 확률 높음

- 우선 완전 검색으로 접근 하여 해답 도출 후, 성능 개선을 위해 다른 알고리즘을

  다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.



### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는것

- 서로 다른 n 개 중 r 개를 택하는 순열

  - nPr

- nPr

  - > n * (n-1) * ( n - 2) * ... * ( n - r + 1 )

- nPn = n!



ex)

```python
# { 1, 2, 3} 을 포함하는 모든 순열을 생성하는 함수
# 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop를 이용해 구현
for i in range(1,4):
    for j in range(1,4):
        if j != i :
            for k in range(1,4):
                if k != i and k!= j:
                    print(i,j,k)
```





### 탐욕 알고리즘

- 최적해를 구하는 데 사용되는 근시안적인 방법

- 여러 경우 중 하나를 결정해야 할 때 마다 ,그 순간에 최적이라고 생각 되는 것을

  선택해 나가는 방식

- 머릿 속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.



### 탐욕 알고리즘의 동작 과정

1) 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤 이를 부분해집합에 추가
2) 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지, 제약조건 위반 확인
3) 해 검사 : 새로운 부분해 집합이 문제의 해가 되는가?

